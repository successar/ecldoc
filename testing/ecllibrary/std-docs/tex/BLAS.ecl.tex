\chapter*{BLAS}
\hypertarget{ecldoc:toc:BLAS}{}

\section*{\underline{IMPORTS}}
\begin{itemize}
\item lib\_eclblas
\end{itemize}

\section*{\underline{DESCRIPTIONS}}
\subsection*{MODULE : BLAS}
\hypertarget{ecldoc:BLAS}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & BLAS \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:toc:root}{Up}

\par


\hyperlink{ecldoc:BLAS.Types}{Types}  |
\hyperlink{ecldoc:blas.icellfunc}{ICellFunc}  |
\hyperlink{ecldoc:blas.apply2cells}{Apply2Cells}  |
\hyperlink{ecldoc:blas.dasum}{dasum}  |
\hyperlink{ecldoc:blas.daxpy}{daxpy}  |
\hyperlink{ecldoc:blas.dgemm}{dgemm}  |
\hyperlink{ecldoc:blas.dgetf2}{dgetf2}  |
\hyperlink{ecldoc:blas.dpotf2}{dpotf2}  |
\hyperlink{ecldoc:blas.dscal}{dscal}  |
\hyperlink{ecldoc:blas.dsyrk}{dsyrk}  |
\hyperlink{ecldoc:blas.dtrsm}{dtrsm}  |
\hyperlink{ecldoc:blas.extract_diag}{extract\_diag}  |
\hyperlink{ecldoc:blas.extract_tri}{extract\_tri}  |
\hyperlink{ecldoc:blas.make_diag}{make\_diag}  |
\hyperlink{ecldoc:blas.make_vector}{make\_vector}  |
\hyperlink{ecldoc:blas.trace}{trace}  |

\rule{\textwidth}{0.4pt}

\subsection*{MODULE : Types}
\hypertarget{ecldoc:BLAS.Types}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & Types \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par


\hyperlink{ecldoc:blas.types.value_t}{value\_t}  |
\hyperlink{ecldoc:blas.types.dimension_t}{dimension\_t}  |
\hyperlink{ecldoc:blas.types.matrix_t}{matrix\_t}  |
\hyperlink{ecldoc:ecldoc-Triangle}{Triangle}  |
\hyperlink{ecldoc:ecldoc-Diagonal}{Diagonal}  |
\hyperlink{ecldoc:ecldoc-Side}{Side}  |

\rule{\textwidth}{0.4pt}

\subsection*{ATTRIBUTE : value\_t}
\hypertarget{ecldoc:blas.types.value_t}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & value\_t \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}
\subsection*{ATTRIBUTE : dimension\_t}
\hypertarget{ecldoc:blas.types.dimension_t}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & dimension\_t \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}
\subsection*{ATTRIBUTE : matrix\_t}
\hypertarget{ecldoc:blas.types.matrix_t}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & matrix\_t \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}
\subsection*{ATTRIBUTE : Triangle}
\hypertarget{ecldoc:ecldoc-Triangle}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & Triangle \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}
\subsection*{ATTRIBUTE : Diagonal}
\hypertarget{ecldoc:ecldoc-Diagonal}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & Diagonal \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}
\subsection*{ATTRIBUTE : Side}
\hypertarget{ecldoc:ecldoc-Side}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt} & Side \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS.Types}{Up}

\par


\rule{\textwidth}{0.4pt}


\subsection*{FUNCTION : ICellFunc}
\hypertarget{ecldoc:blas.icellfunc}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.value\_t & ICellFunc \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.value\_t v, Types.dimension\_t r, Types.dimension\_t c)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Function prototype for Apply2Cell.

\par
\begin{description}
\item [\textbf{Parameter}] v ||| the value
\item [\textbf{Parameter}] r ||| the row ordinal
\item [\textbf{Parameter}] c ||| the column ordinal
\item [\textbf{Return}] the updated value
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : Apply2Cells}
\hypertarget{ecldoc:blas.apply2cells}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & Apply2Cells \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.dimension\_t n, Types.matrix\_t x, ICellFunc f)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Iterate matrix and apply function to each cell

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of rows
\item [\textbf{Parameter}] n ||| number of columns
\item [\textbf{Parameter}] x ||| matrix
\item [\textbf{Parameter}] f ||| function to apply
\item [\textbf{Return}] updated matrix
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dasum}
\hypertarget{ecldoc:blas.dasum}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.value\_t & dasum \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.matrix\_t x, Types.dimension\_t incx, Types.dimension\_t skipped=0)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Absolute sum, the 1 norm of a vector.

\par
\begin{description}
\item [\textbf{Parameter}] m ||| the number of entries
\item [\textbf{Parameter}] x ||| the column major matrix holding the vector
\item [\textbf{Parameter}] incx ||| the increment for x, 1 in the case of an actual vector
\item [\textbf{Parameter}] skipped ||| default is zero, the number of entries stepped over to get to the first entry
\item [\textbf{Return}] the sum of the absolute values
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : daxpy}
\hypertarget{ecldoc:blas.daxpy}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & daxpy \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t N, Types.value\_t alpha, Types.matrix\_t X, Types.dimension\_t incX, Types.matrix\_t Y, Types.dimension\_t incY, Types.dimension\_t x\_skipped=0, Types.dimension\_t y\_skipped=0)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
alpha*X + Y

\par
\begin{description}
\item [\textbf{Parameter}] N ||| number of elements in vector
\item [\textbf{Parameter}] alpha ||| the scalar multiplier
\item [\textbf{Parameter}] X ||| the column major matrix holding the vector X
\item [\textbf{Parameter}] incX ||| the increment or stride for the vector
\item [\textbf{Parameter}] Y ||| the column major matrix holding the vector Y
\item [\textbf{Parameter}] incY ||| the increment or stride of Y
\item [\textbf{Parameter}] x\_skipped ||| number of entries skipped to get to the first X
\item [\textbf{Parameter}] y\_skipped ||| number of entries skipped to get to the first Y
\item [\textbf{Return}] the updated matrix
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dgemm}
\hypertarget{ecldoc:blas.dgemm}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dgemm \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(BOOLEAN transposeA, BOOLEAN transposeB, Types.dimension\_t M, Types.dimension\_t N, Types.dimension\_t K, Types.value\_t alpha, Types.matrix\_t A, Types.matrix\_t B, Types.value\_t beta=0.0, Types.matrix\_t C=[])} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
alpha*op(A) op(B) + beta*C where op() is transpose

\par
\begin{description}
\item [\textbf{Parameter}] transposeA ||| true when transpose of A is used
\item [\textbf{Parameter}] transposeB ||| true when transpose of B is used
\item [\textbf{Parameter}] M ||| number of rows in product
\item [\textbf{Parameter}] N ||| number of columns in product
\item [\textbf{Parameter}] K ||| number of columns/rows for the multiplier/multiplicand
\item [\textbf{Parameter}] alpha ||| scalar used on A
\item [\textbf{Parameter}] A ||| matrix A
\item [\textbf{Parameter}] B ||| matrix B
\item [\textbf{Parameter}] beta ||| scalar for matrix C
\item [\textbf{Parameter}] C ||| matrix C or empty
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dgetf2}
\hypertarget{ecldoc:blas.dgetf2}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dgetf2 \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.dimension\_t n, Types.matrix\_t a)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Compute LU Factorization of matrix A.

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of rows of A
\item [\textbf{Parameter}] n ||| number of columns of A
\item [\textbf{Return}] composite matrix of factors, lower triangle has an implied diagonal of ones. Upper triangle has the diagonal of the composite.
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dpotf2}
\hypertarget{ecldoc:blas.dpotf2}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dpotf2 \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.Triangle tri, Types.dimension\_t r, Types.matrix\_t A, BOOLEAN clear=TRUE)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
DPOTF2 computes the Cholesky factorization of a real symmetric positive definite matrix A. The factorization has the form A = U**T * U , if UPLO = 'U', or A = L * L**T, if UPLO = 'L', where U is an upper triangular matrix and L is lower triangular. This is the unblocked version of the algorithm, calling Level 2 BLAS.

\par
\begin{description}
\item [\textbf{Parameter}] tri ||| indicate whether upper or lower triangle is used
\item [\textbf{Parameter}] r ||| number of rows/columns in the square matrix
\item [\textbf{Parameter}] A ||| the square matrix
\item [\textbf{Parameter}] clear ||| clears the unused triangle
\item [\textbf{Return}] the triangular matrix requested.
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dscal}
\hypertarget{ecldoc:blas.dscal}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dscal \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t N, Types.value\_t alpha, Types.matrix\_t X, Types.dimension\_t incX, Types.dimension\_t skipped=0)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Scale a vector alpha

\par
\begin{description}
\item [\textbf{Parameter}] N ||| number of elements in the vector
\item [\textbf{Parameter}] alpha ||| the scaling factor
\item [\textbf{Parameter}] X ||| the column major matrix holding the vector
\item [\textbf{Parameter}] incX ||| the stride to get to the next element in the vector
\item [\textbf{Parameter}] skipped ||| the number of elements skipped to get to the first element
\item [\textbf{Return}] the updated matrix
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dsyrk}
\hypertarget{ecldoc:blas.dsyrk}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dsyrk \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.Triangle tri, BOOLEAN transposeA, Types.dimension\_t N, Types.dimension\_t K, Types.value\_t alpha, Types.matrix\_t A, Types.value\_t beta, Types.matrix\_t C, BOOLEAN clear=FALSE)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Implements symmetric rank update C 

\par
\begin{description}
\item [\textbf{Parameter}] tri ||| update upper or lower triangle
\item [\textbf{Parameter}] transposeA ||| Transpose the A matrix to be NxK
\item [\textbf{Parameter}] N ||| number of rows
\item [\textbf{Parameter}] K ||| number of columns in the update matrix or transpose
\item [\textbf{Parameter}] alpha ||| the alpha scalar
\item [\textbf{Parameter}] A ||| the update matrix, either NxK or KxN
\item [\textbf{Parameter}] beta ||| the beta scalar
\item [\textbf{Parameter}] C ||| the matrix to update
\item [\textbf{Parameter}] clear ||| clear the triangle that is not updated. BLAS assumes that symmetric matrices have only one of the triangles and this option lets you make that true.
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : dtrsm}
\hypertarget{ecldoc:blas.dtrsm}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & dtrsm \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.Side side, Types.Triangle tri, BOOLEAN transposeA, Types.Diagonal diag, Types.dimension\_t M, Types.dimension\_t N, Types.dimension\_t lda, Types.value\_t alpha, Types.matrix\_t A, Types.matrix\_t B)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Triangular matrix solver. op(A) X = alpha B or X op(A) = alpha B where op is Transpose, X and B is MxN

\par
\begin{description}
\item [\textbf{Parameter}] side ||| side for A, Side.Ax is op(A) X = alpha B
\item [\textbf{Parameter}] tri ||| Says whether A is Upper or Lower triangle
\item [\textbf{Parameter}] transposeA ||| is op(A) the transpose of A
\item [\textbf{Parameter}] diag ||| is the diagonal an implied unit diagonal or supplied
\item [\textbf{Parameter}] M ||| number of rows
\item [\textbf{Parameter}] N ||| number of columns
\item [\textbf{Parameter}] lda ||| the leading dimension of the A matrix, either M or N
\item [\textbf{Parameter}] alpha ||| the scalar multiplier for B
\item [\textbf{Parameter}] A ||| a triangular matrix
\item [\textbf{Parameter}] B ||| the matrix of values for the solve
\item [\textbf{Return}] the matrix of coefficients to get B.
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : extract\_diag}
\hypertarget{ecldoc:blas.extract_diag}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & extract\_diag \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.dimension\_t n, Types.matrix\_t x)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Extract the diagonal of he matrix

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of rows
\item [\textbf{Parameter}] n ||| number of columns
\item [\textbf{Parameter}] x ||| matrix from which to extract the diagonal
\item [\textbf{Return}] diagonal matrix
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : extract\_tri}
\hypertarget{ecldoc:blas.extract_tri}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & extract\_tri \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.dimension\_t n, Types.Triangle tri, Types.Diagonal dt, Types.matrix\_t a)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Extract the upper or lower triangle. Diagonal can be actual or implied unit diagonal.

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of rows
\item [\textbf{Parameter}] n ||| number of columns
\item [\textbf{Parameter}] tri ||| Upper or Lower specifier, Triangle.Lower or Triangle.Upper
\item [\textbf{Parameter}] dt ||| Use Diagonal.NotUnitTri or Diagonal.UnitTri
\item [\textbf{Parameter}] a ||| Matrix, usually a composite from factoring
\item [\textbf{Return}] the triangle
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : make\_diag}
\hypertarget{ecldoc:blas.make_diag}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & make\_diag \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.value\_t v=1.0, Types.matrix\_t X=[])} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Generate a diagonal matrix.

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of diagonal entries
\item [\textbf{Parameter}] v ||| option value, defaults to 1
\item [\textbf{Parameter}] X ||| optional input of diagonal values, multiplied by v.
\item [\textbf{Return}] a diagonal matrix
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : make\_vector}
\hypertarget{ecldoc:blas.make_vector}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.matrix\_t & make\_vector \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.value\_t v=1.0)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
Make a vector of dimension m

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of elements
\item [\textbf{Parameter}] v ||| the values, defaults to 1
\item [\textbf{Return}] the vector
\end{description}

\rule{\textwidth}{0.4pt}
\subsection*{FUNCTION : trace}
\hypertarget{ecldoc:blas.trace}{}

{\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}l|X|}
\hline
\hspace{0pt}Types.value\_t & trace \\
\hline
\multicolumn{2}{|>{\raggedright\arraybackslash}X|}{\hspace{0pt}(Types.dimension\_t m, Types.dimension\_t n, Types.matrix\_t x)} \\
\hline
\end{tabularx}
}

\hyperlink{ecldoc:BLAS}{Up}

\par
The trace of the input matrix

\par
\begin{description}
\item [\textbf{Parameter}] m ||| number of rows
\item [\textbf{Parameter}] n ||| number of columns
\item [\textbf{Parameter}] x ||| the matrix
\item [\textbf{Return}] the trace (sum of the diagonal entries)
\end{description}

\rule{\textwidth}{0.4pt}



<?xml version='1.0' encoding='UTF-8'?>
<Meta>
 <Depends sourcePath="lib_fileservices" target="lib_fileservices"/><Source name="File" sourcePath="/media/sarthak/Data/ecldoc/testing/ecllibrary/std/File.ecl" target="File.ecl.xml">
  <Import name="lib_fileservices" ref="lib_fileservices" remotescope="1" target="lib_fileservices/pkg.toc.xml"/>
  <Definition exported="1" fullname="File" inherittype="local" line="5" name="File">
   <Type>module</Type>
   <Definition exported="1" fullname="file.fsfilenamerecord" inherittype="local" line="19" name="FsFilenameRecord">
    <Type>record</Type>
    <Field name="name" type="string"/>
    <Field name="size" type="integer8"/>
    <Field name="modified" type="string19"/>
    <Signature name="FsFilenameRecord" ret="" param="" hlen="16">FsFilenameRecord</Signature><Documentation>
     <firstline>A record containing information about filename</firstline><content>A record containing information about filename. Includes name, size and when last modified. export FsFilenameRecord := RECORD string name; integer8 size; string19 modified; END;</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fslogicalfilename" inherittype="local" line="25" name="FsLogicalFileName">
    <Type>attribute</Type>
    <Signature name="FsLogicalFileName" ret="" param="" hlen="17">FsLogicalFileName</Signature><Documentation>
     <firstline>An alias for a logical filename that is stored in a row</firstline><content>An alias for a logical filename that is stored in a row.</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fslogicalfilenamerecord" inherittype="local" line="33" name="FsLogicalFileNameRecord">
    <Type>record</Type>
    <Field name="name" type="string"/>
    <Signature name="FsLogicalFileNameRecord" ret="" param="" hlen="23">FsLogicalFileNameRecord</Signature><Documentation>
     <firstline>A record containing a logical filename</firstline><content>A record containing a logical filename. It contains the following fields:</content><field><name>name</name><desc>The logical name of the file;</desc></field></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fslogicalfileinforecord" inherittype="local" line="47" name="FsLogicalFileInfoRecord">
    <Type>record</Type>
    <Field name="name" type="string"/>
    <Field name="superfile" type="boolean"/>
    <Field name="size" type="integer8"/>
    <Field name="rowcount" type="integer8"/>
    <Field name="modified" type="string19"/>
    <Field name="owner" type="string"/>
    <Field name="cluster" type="string"/>
    <Signature name="FsLogicalFileInfoRecord" ret="" param="" hlen="23">FsLogicalFileInfoRecord</Signature><Documentation>
     <owner>The username of the owner who ran the job to create this file.</owner><modified>Timestamp when the file was last modified;</modified><firstline>A record containing information about a logical file</firstline><inherits>Contains all the fields in FsLogicalFileNameRecord)</inherits><content>A record containing information about a logical file.</content><field><name>superfile</name><desc>Is this a superfile?</desc></field><field><name>size</name><desc>Number of bytes in the file (before compression)</desc></field><field><name>rowcount</name><desc>Number of rows in the file.</desc></field><cluster>The cluster that this file was created on.</cluster></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fslogicalsupersubrecord" inherittype="local" line="56" name="FsLogicalSuperSubRecord">
    <Type>record</Type>
    <Field name="supername" type="string"/>
    <Field name="subname" type="string"/>
    <Signature name="FsLogicalSuperSubRecord" ret="" param="" hlen="23">FsLogicalSuperSubRecord</Signature><Documentation>
     <firstline>A record containing information about a superfile and its contents</firstline><content>A record containing information about a superfile and its contents.</content><field><name>supername</name><desc>The name of the superfile</desc></field><field><name>subname</name><desc>The name of the sub-file</desc></field></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fsfilerelationshiprecord" inherittype="local" line="74" name="FsFileRelationshipRecord">
    <Type>record</Type>
    <Field name="primaryfile" type="string"/>
    <Field name="secondaryfile" type="string"/>
    <Field name="primaryflds" type="string"/>
    <Field name="secondaryflds" type="string"/>
    <Field name="kind" type="string"/>
    <Field name="cardinality" type="string"/>
    <Field name="payload" type="boolean"/>
    <Field name="description" type="string"/>
    <Signature name="FsFileRelationshipRecord" ret="" param="" hlen="24">FsFileRelationshipRecord</Signature><Documentation>
     <firstline>A record containing information about the relationship between two files</firstline><content>A record containing information about the relationship between two files.</content><field><name>primaryfile</name><desc>The logical filename of the primary file</desc></field><field><name>secondaryfile</name><desc>The logical filename of the secondary file.</desc></field><field><name>primaryflds</name><desc>The name of the primary key field for the primary file. The value "__fileposition__" indicates the secondary is an INDEX that must use FETCH to access non-keyed fields.</desc></field><field><name>secondaryflds</name><desc>The name of the foreign key field relating to the primary file.</desc></field><field><name>kind</name><desc>The type of relationship between the primary and secondary files. Containing either 'link' or 'view'.</desc></field><field><name>cardinality</name><desc>The cardinality of the relationship. The format is &lt;primary&gt;:&lt;secondary&gt;. Valid values are "1" or "M".&lt;/secondary&gt;&lt;/primary&gt;</desc></field><field><name>payload</name><desc>Indicates whether the primary or secondary are payload INDEXes.</desc></field><field><name>description</name><desc>The description of the relationship.</desc></field></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.recfmv_recsize" inherittype="local" line="80" name="RECFMV_RECSIZE">
    <Type>attribute</Type>
    <Signature name="RECFMV_RECSIZE" ret="" param="" hlen="14">RECFMV_RECSIZE</Signature><Documentation>
     <firstline>Constant that indicates IBM RECFM V format file</firstline><content>Constant that indicates IBM RECFM V format file. Can be passed to SprayFixed for the record size.</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.recfmvb_recsize" inherittype="local" line="86" name="RECFMVB_RECSIZE">
    <Type>attribute</Type>
    <Signature name="RECFMVB_RECSIZE" ret="" param="" hlen="15">RECFMVB_RECSIZE</Signature><Documentation>
     <firstline>Constant that indicates IBM RECFM VB format file</firstline><content>Constant that indicates IBM RECFM VB format file. Can be passed to SprayFixed for the record size.</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.prefix_variable_recsize" inherittype="local" line="92" name="PREFIX_VARIABLE_RECSIZE">
    <Type>attribute</Type>
    <Signature name="PREFIX_VARIABLE_RECSIZE" ret="INTEGER4" param="" hlen="32">INTEGER4 PREFIX_VARIABLE_RECSIZE</Signature><Documentation>
     <firstline>Constant that indicates a variable little endian 4 byte length prefixed file</firstline><content>Constant that indicates a variable little endian 4 byte length prefixed file. Can be passed to SprayFixed for the record size.</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.prefix_variable_bigendian_recsize" inherittype="local" line="98" name="PREFIX_VARIABLE_BIGENDIAN_RECSIZE">
    <Type>attribute</Type>
    <Signature name="PREFIX_VARIABLE_BIGENDIAN_RECSIZE" ret="INTEGER4" param="" hlen="42">INTEGER4 PREFIX_VARIABLE_BIGENDIAN_RECSIZE</Signature><Documentation>
     <firstline>Constant that indicates a variable big endian 4 byte length prefixed file</firstline><content>Constant that indicates a variable big endian 4 byte length prefixed file. Can be passed to SprayFixed for the record size.</content></Documentation>
   </Definition>
   <Definition exported="1" fullname="file.fileexists" inherittype="local" line="110" name="FileExists">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical name of the file.</desc></param><param><name>physical</name><desc>Whether to also check for the physical existence on disk. Defaults to FALSE.</desc></param><firstline>Returns whether the file exists</firstline><content>Returns whether the file exists.</content><return>Whether the file exists.</return></Documentation>
    <Signature name="FileExists" ret="boolean" param="(varstring lfn, boolean physical=FALSE)" hlen="18">boolean FileExists(varstring lfn, boolean physical=FALSE)</Signature><Params>
     <Param name="lfn"/>
     <Param name="physical"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.deletelogicalfile" inherittype="local" line="120" name="DeleteLogicalFile">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical name of the file.</desc></param><param><name>allowMissing</name><desc>Whether to suppress an error if the filename does not exist. Defaults to FALSE.</desc></param><firstline>Removes the logical file from the system, and deletes from the disk</firstline><content>Removes the logical file from the system, and deletes from the disk.</content></Documentation>
    <Signature name="DeleteLogicalFile" ret="" param="(varstring lfn, boolean allowMissing=FALSE)" hlen="17">DeleteLogicalFile(varstring lfn, boolean allowMissing=FALSE)</Signature><Params>
     <Param name="lfn"/>
     <Param name="allowMissing"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.setreadonly" inherittype="local" line="129" name="SetReadOnly">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical name of the file.</desc></param><param><name>ro</name><desc>Whether updates to the file are disallowed. Defaults to TRUE.</desc></param><firstline>Changes whether access to a file is read only or not</firstline><content>Changes whether access to a file is read only or not.</content></Documentation>
    <Signature name="SetReadOnly" ret="" param="(varstring lfn, boolean ro=TRUE)" hlen="11">SetReadOnly(varstring lfn, boolean ro=TRUE)</Signature><Params>
     <Param name="lfn"/>
     <Param name="ro"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.renamelogicalfile" inherittype="local" line="139" name="RenameLogicalFile">
    <Type>function</Type>
    <Documentation>
     <param><name>oldname</name><desc>The current name of the file to be renamed.</desc></param><param><name>newname</name><desc>The new logical name of the file.</desc></param><firstline>Changes the name of a logical file</firstline><content>Changes the name of a logical file.</content></Documentation>
    <Signature name="RenameLogicalFile" ret="" param="(varstring oldname, varstring newname)" hlen="17">RenameLogicalFile(varstring oldname, varstring newname)</Signature><Params>
     <Param name="oldname"/>
     <Param name="newname"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.foreignlogicalfilename" inherittype="local" line="151" name="ForeignLogicalFileName">
    <Type>function</Type>
    <Documentation>
     <param><name>name</name><desc>The logical name of the file.</desc></param><param><name>foreigndali</name><desc>The IP address of the foreign dali used to resolve the file. If blank then the file is resolved locally. Defaults to blank.</desc></param><param><name>abspath</name><desc>Should a tilde (~) be prepended to the resulting logical file name. Defaults to FALSE.</desc></param><firstline>Returns a logical filename that can be used to refer to a logical file in a local or remote dali</firstline><content>Returns a logical filename that can be used to refer to a logical file in a local or remote dali.</content></Documentation>
    <Signature name="ForeignLogicalFileName" ret="varstring" param="(varstring name, varstring foreigndali='', boolean abspath=FALSE)" hlen="32">varstring ForeignLogicalFileName(varstring name, varstring foreigndali='', boolean abspath=FALSE)</Signature><Params>
     <Param name="name"/>
     <Param name="foreigndali"/>
     <Param name="abspath"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.externallogicalfilename" inherittype="local" line="164" name="ExternalLogicalFileName">
    <Type>function</Type>
    <Documentation>
     <param><name>location</name><desc>The IP address of the remote machine. '.' can be used for the local machine.</desc></param><param><name>path</name><desc>The path/name of the file on the remote machine.</desc></param><param><name>abspath</name><desc>Should a tilde (~) be prepended to the resulting logical file name. Defaults to TRUE.</desc></param><firstline>Returns an encoded logical filename that can be used to refer to a external file</firstline><content>Returns an encoded logical filename that can be used to refer to a external file. Examples include directly reading from a landing zone. Upper case characters and other details are escaped.</content><return>The encoded logical filename.</return></Documentation>
    <Signature name="ExternalLogicalFileName" ret="varstring" param="(varstring location, varstring path, boolean abspath=TRUE)" hlen="33">varstring ExternalLogicalFileName(varstring location, varstring path, boolean abspath=TRUE)</Signature><Params>
     <Param name="location"/>
     <Param name="path"/>
     <Param name="abspath"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.getfiledescription" inherittype="local" line="174" name="GetFileDescription">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical name of the file.</desc></param><firstline>Returns a string containing the description information associated with the specified filename</firstline><content>Returns a string containing the description information associated with the specified filename. This description is set either through ECL watch or by using the FileServices.SetFileDescription function.</content></Documentation>
    <Signature name="GetFileDescription" ret="varstring" param="(varstring lfn)" hlen="28">varstring GetFileDescription(varstring lfn)</Signature><Params>
     <Param name="lfn"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.setfiledescription" inherittype="local" line="184" name="SetFileDescription">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical name of the file.</desc></param><param><name>val</name><desc>The description to be associated with the file.</desc></param><firstline>Sets the description associated with the specified filename</firstline><content>Sets the description associated with the specified filename.</content></Documentation>
    <Signature name="SetFileDescription" ret="" param="(varstring lfn, varstring val)" hlen="18">SetFileDescription(varstring lfn, varstring val)</Signature><Params>
     <Param name="lfn"/>
     <Param name="val"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.remotedirectory" inherittype="local" line="196" name="RemoteDirectory">
    <Type>function</Type>
    <Documentation>
     <param><name>machineIP</name><desc>The IP address of the remote machine.</desc></param><param><name>directory</name><desc>The path to the directory to read. This must be in the appropriate format for the operating system running on the remote machine.</desc></param><param><name>mask</name><desc>The filemask specifying which files to include in the result. Defaults to '*' (all files).</desc></param><param><name>recurse</name><desc>Whether to include files from subdirectories under the directory. Defaults to FALSE.</desc></param><firstline>Returns a dataset containing a list of files from the specified machineIP and directory</firstline><content>Returns a dataset containing a list of files from the specified machineIP and directory.</content></Documentation>
    <Signature name="RemoteDirectory" ret="dataset(FsFilenameRecord)" param="(varstring machineIP, varstring dir, varstring mask='*', boolean recurse=FALSE)" hlen="41">dataset(FsFilenameRecord) RemoteDirectory(varstring machineIP, varstring dir, varstring mask='*', boolean recurse=FALSE)</Signature><Params>
     <Param name="machineIP"/>
     <Param name="dir"/>
     <Param name="mask"/>
     <Param name="recurse"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.logicalfilelist" inherittype="local" line="209" name="LogicalFileList">
    <Type>function</Type>
    <Documentation>
     <param><name>namepattern</name><desc>The mask of the files to list. Defaults to '*' (all files).</desc></param><param><name>includenormal</name><desc>Whether to include 'normal' files. Defaults to TRUE.</desc></param><param><name>includesuper</name><desc>Whether to include SuperFiles. Defaults to FALSE.</desc></param><param><name>unknownszero</name><desc>Whether to set file sizes that are unknown to zero(0) instead of minus-one (-1). Defaults to FALSE.</desc></param><param><name>foreigndali</name><desc>The IP address of the foreign dali used to resolve the file. If blank then the file is resolved locally. Defaults to blank.</desc></param><firstline>Returns a dataset of information about the logical files known to the system</firstline><content>Returns a dataset of information about the logical files known to the system.</content></Documentation>
    <Signature name="LogicalFileList" ret="dataset(FsLogicalFileInfoRecord)" param="(varstring namepattern='*', boolean includenormal=TRUE, boolean includesuper=FALSE, boolean unknownszero=FALSE, varstring foreigndali='')" hlen="48">dataset(FsLogicalFileInfoRecord) LogicalFileList(varstring namepattern='*', boolean includenormal=TRUE, boolean includesuper=FALSE, boolean unknownszero=FALSE, varstring foreigndali='')</Signature><Params>
     <Param name="namepattern"/>
     <Param name="includenormal"/>
     <Param name="includesuper"/>
     <Param name="unknownszero"/>
     <Param name="foreigndali"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.comparefiles" inherittype="local" line="228" name="CompareFiles">
    <Type>function</Type>
    <Documentation>
     <param><name>file1</name><desc>The logical name of the first file.</desc></param><param><name>file2</name><desc>The logical name of the second file.</desc></param><param><name>logical_only</name><desc>Whether to only compare logical information in the system datastore (Dali), and ignore physical information on disk. [Default TRUE]</desc></param><param><name>use_crcs</name><desc>Whether to compare physical CRCs of all the parts on disk. This may be slow on large files. Defaults to FALSE.</desc></param><firstline>Compares two files, and returns a result indicating how well they match</firstline><content>Compares two files, and returns a result indicating how well they match.</content><return>0 if file1 and file2 match exactly 1 if file1 and file2 contents match, but file1 is newer than file2 -1 if file1 and file2 contents match, but file2 is newer than file1 2 if file1 and file2 contents do not match and file1 is newer than file2 -2 if file1 and file2 contents do not match and file2 is newer than file1</return></Documentation>
    <Signature name="CompareFiles" ret="INTEGER4" param="(varstring lfn1, varstring lfn2, boolean logical_only=TRUE, boolean use_crcs=FALSE)" hlen="21">INTEGER4 CompareFiles(varstring lfn1, varstring lfn2, boolean logical_only=TRUE, boolean use_crcs=FALSE)</Signature><Params>
     <Param name="lfn1"/>
     <Param name="lfn2"/>
     <Param name="logical_only"/>
     <Param name="use_crcs"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.verifyfile" inherittype="local" line="244" name="VerifyFile">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The name of the file to check.</desc></param><param><name>use_crcs</name><desc>Whether to compare physical CRCs of all the parts on disk. This may be slow on large files.</desc></param><firstline>Checks the system datastore (Dali) information for the file against the physical parts on disk</firstline><content>Checks the system datastore (Dali) information for the file against the physical parts on disk.</content><return>'OK' - The file parts match the datastore information 'Could not find file: &lt;filename&gt;' - The logical filename was not found 'Could not find part file: &lt;partname&gt;' - The partname was not found 'Modified time differs for: &lt;partname&gt;' - The partname has a different timestamp 'File size differs for: &lt;partname&gt;' - The partname has a file size 'File CRC differs for: &lt;partname&gt;' - The partname has a different CRC&lt;/partname&gt;&lt;/partname&gt;&lt;/partname&gt;&lt;/partname&gt;&lt;/filename&gt;</return></Documentation>
    <Signature name="VerifyFile" ret="varstring" param="(varstring lfn, boolean usecrcs)" hlen="20">varstring VerifyFile(varstring lfn, boolean usecrcs)</Signature><Params>
     <Param name="lfn"/>
     <Param name="usecrcs"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.addfilerelationship" inherittype="local" line="265" name="AddFileRelationship">
    <Type>function</Type>
    <Documentation>
     <param><name>primary</name><desc>The logical filename of the primary file.</desc></param><param><name>secondary</name><desc>The logical filename of the secondary file.</desc></param><param><name>primaryfields</name><desc>The name of the primary key field for the primary file. The value "__fileposition__" indicates the secondary is an INDEX that must use FETCH to access non-keyed fields.</desc></param><param><name>secondaryfields</name><desc>The name of the foreign key field relating to the primary file.</desc></param><param><name>relationship</name><desc>The type of relationship between the primary and secondary files. Containing either 'link' or 'view'. Default is "link".</desc></param><param><name>cardinality</name><desc>The cardinality of the relationship. The format is &lt;primary&gt;:&lt;secondary&gt;. Valid values are "1" or "M".&lt;/secondary&gt;&lt;/primary&gt;</desc></param><param><name>payload</name><desc>Indicates whether the primary or secondary are payload INDEXes.</desc></param><param><name>description</name><desc>The description of the relationship.</desc></param><firstline>Defines the relationship between two files</firstline><content>Defines the relationship between two files. These may be DATASETs or INDEXes. Each record in the primary file should be uniquely defined by the primaryfields (ideally), preferably efficiently. This information is used by the roxie browser to link files together.</content></Documentation>
    <Signature name="AddFileRelationship" ret="" param="(varstring primary, varstring secondary, varstring primaryflds, varstring secondaryflds, varstring kind='link', varstring cardinality, boolean payload, varstring description='')" hlen="19">AddFileRelationship(varstring primary, varstring secondary, varstring primaryflds, varstring secondaryflds, varstring kind='link', varstring cardinality, boolean payload, varstring description='')</Signature><Params>
     <Param name="primary"/>
     <Param name="secondary"/>
     <Param name="primaryflds"/>
     <Param name="secondaryflds"/>
     <Param name="kind"/>
     <Param name="cardinality"/>
     <Param name="payload"/>
     <Param name="description"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.filerelationshiplist" inherittype="local" line="279" name="FileRelationshipList">
    <Type>function</Type>
    <Documentation>
     <param><name>primary</name><desc>The logical filename of the primary file.</desc></param><param><name>secondary</name><desc>The logical filename of the secondary file.</desc></param><param><name>primaryfields</name><desc>The name of the primary key field for the primary file.</desc></param><param><name>secondaryfields</name><desc>The name of the foreign key field relating to the primary file.</desc></param><param><name>relationship</name><desc>The type of relationship between the primary and secondary files. Containing either 'link' or 'view'. Default is "link".</desc></param><firstline>Returns a dataset of relationships</firstline><content>Returns a dataset of relationships. The return records are structured in the FsFileRelationshipRecord format.</content></Documentation>
    <Signature name="FileRelationshipList" ret="dataset(FsFileRelationshipRecord)" param="(varstring primary, varstring secondary, varstring primflds='', varstring secondaryflds='', varstring kind='link')" hlen="54">dataset(FsFileRelationshipRecord) FileRelationshipList(varstring primary, varstring secondary, varstring primflds='', varstring secondaryflds='', varstring kind='link')</Signature><Params>
     <Param name="primary"/>
     <Param name="secondary"/>
     <Param name="primflds"/>
     <Param name="secondaryflds"/>
     <Param name="kind"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.removefilerelationship" inherittype="local" line="293" name="RemoveFileRelationship">
    <Type>function</Type>
    <Documentation>
     <param><name>primary</name><desc>The logical filename of the primary file.</desc></param><param><name>secondary</name><desc>The logical filename of the secondary file.</desc></param><param><name>primaryfields</name><desc>The name of the primary key field for the primary file.</desc></param><param><name>secondaryfields</name><desc>The name of the foreign key field relating to the primary file.</desc></param><param><name>relationship</name><desc>The type of relationship between the primary and secondary files. Containing either 'link' or 'view'. Default is "link".</desc></param><firstline>Removes a relationship between two files</firstline><content>Removes a relationship between two files.</content></Documentation>
    <Signature name="RemoveFileRelationship" ret="" param="(varstring primary, varstring secondary, varstring primaryflds='', varstring secondaryflds='', varstring kind='link')" hlen="22">RemoveFileRelationship(varstring primary, varstring secondary, varstring primaryflds='', varstring secondaryflds='', varstring kind='link')</Signature><Params>
     <Param name="primary"/>
     <Param name="secondary"/>
     <Param name="primaryflds"/>
     <Param name="secondaryflds"/>
     <Param name="kind"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.getcolumnmapping" inherittype="local" line="302" name="GetColumnMapping">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical filename of the primary file.</desc></param><firstline>Returns the field mappings for the file, in the same format specified for the SetColumnMapping function</firstline><content>Returns the field mappings for the file, in the same format specified for the SetColumnMapping function.</content></Documentation>
    <Signature name="GetColumnMapping" ret="varstring" param="(varstring lfn)" hlen="26">varstring GetColumnMapping(varstring lfn)</Signature><Params>
     <Param name="lfn"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.setcolumnmapping" inherittype="local" line="313" name="SetColumnMapping">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The logical filename of the primary file.</desc></param><param><name>mapping</name><desc>A string containing a comma separated list of field mappings.</desc></param><firstline>Defines how the data in the fields of the file mist be transformed between the actual data storage format and the input format used to query that data</firstline><content>Defines how the data in the fields of the file mist be transformed between the actual data storage format and the input format used to query that data. This is used by the user interface of the roxie browser.</content></Documentation>
    <Signature name="SetColumnMapping" ret="" param="(varstring lfn, varstring mapping)" hlen="16">SetColumnMapping(varstring lfn, varstring mapping)</Signature><Params>
     <Param name="lfn"/>
     <Param name="mapping"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.encoderfsquery" inherittype="local" line="324" name="EncodeRfsQuery">
    <Type>function</Type>
    <Documentation>
     <param><name>server</name><desc>A string containing the ip:port address for the remote file server.</desc></param><param><name>query</name><desc>The text of the query to send to the server</desc></param><firstline>Returns a string that can be used in a DATASET declaration to read data from an RFS (Remote File Server) instance (e.g</firstline><content>Returns a string that can be used in a DATASET declaration to read data from an RFS (Remote File Server) instance (e.g. rfsmysql) on another node.</content></Documentation>
    <Signature name="EncodeRfsQuery" ret="varstring" param="(varstring server, varstring query)" hlen="24">varstring EncodeRfsQuery(varstring server, varstring query)</Signature><Params>
     <Param name="server"/>
     <Param name="query"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.rfsaction" inherittype="local" line="334" name="RfsAction">
    <Type>function</Type>
    <Documentation>
     <param><name>server</name><desc>A string containing the ip:port address for the remote file server.</desc></param><param><name>query</name><desc>The text of the query to send to the server</desc></param><firstline>Sends the query to the rfs server</firstline><content>Sends the query to the rfs server.</content></Documentation>
    <Signature name="RfsAction" ret="" param="(varstring server, varstring query)" hlen="9">RfsAction(varstring server, varstring query)</Signature><Params>
     <Param name="server"/>
     <Param name="query"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.moveexternalfile" inherittype="local" line="345" name="MoveExternalFile">
    <Type>function</Type>
    <Documentation>
     <param><name>location</name><desc>The IP address of the remote machine.</desc></param><param><name>frompath</name><desc>The path/name of the file to move.</desc></param><param><name>topath</name><desc>The path/name of the target file.</desc></param><firstline>Moves the single physical file between two locations on the same remote machine</firstline><content>Moves the single physical file between two locations on the same remote machine. The dafileserv utility program must be running on the location machine.</content></Documentation>
    <Signature name="MoveExternalFile" ret="" param="(varstring location, varstring frompath, varstring topath)" hlen="16">MoveExternalFile(varstring location, varstring frompath, varstring topath)</Signature><Params>
     <Param name="location"/>
     <Param name="frompath"/>
     <Param name="topath"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.deleteexternalfile" inherittype="local" line="355" name="DeleteExternalFile">
    <Type>function</Type>
    <Documentation>
     <param><name>location</name><desc>The IP address of the remote machine.</desc></param><param><name>path</name><desc>The path/name of the file to remove.</desc></param><firstline>Removes a single physical file from a remote machine</firstline><content>Removes a single physical file from a remote machine. The dafileserv utility program must be running on the location machine.</content></Documentation>
    <Signature name="DeleteExternalFile" ret="" param="(varstring location, varstring path)" hlen="18">DeleteExternalFile(varstring location, varstring path)</Signature><Params>
     <Param name="location"/>
     <Param name="path"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.createexternaldirectory" inherittype="local" line="365" name="CreateExternalDirectory">
    <Type>function</Type>
    <Documentation>
     <param><name>location</name><desc>The IP address of the remote machine.</desc></param><param><name>path</name><desc>The path/name of the file to remove.</desc></param><firstline>Creates the path on the location (if it does not already exist)</firstline><content>Creates the path on the location (if it does not already exist). The dafileserv utility program must be running on the location machine.</content></Documentation>
    <Signature name="CreateExternalDirectory" ret="" param="(varstring location, varstring path)" hlen="23">CreateExternalDirectory(varstring location, varstring path)</Signature><Params>
     <Param name="location"/>
     <Param name="path"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.getlogicalfileattribute" inherittype="local" line="374" name="GetLogicalFileAttribute">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The name of the logical file.</desc></param><param><name>attrname</name><desc>The name of the file attribute to return.</desc></param><firstline>Returns the value of the given attribute for the specified logicalfilename</firstline><content>Returns the value of the given attribute for the specified logicalfilename.</content></Documentation>
    <Signature name="GetLogicalFileAttribute" ret="varstring" param="(varstring lfn, varstring attrname)" hlen="33">varstring GetLogicalFileAttribute(varstring lfn, varstring attrname)</Signature><Params>
     <Param name="lfn"/>
     <Param name="attrname"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.protectlogicalfile" inherittype="local" line="383" name="ProtectLogicalFile">
    <Type>function</Type>
    <Documentation>
     <param><name>lfn</name><desc>The name of the logical file.</desc></param><param><name>value</name><desc>TRUE to enable protection, FALSE to disable.</desc></param><firstline>Toggles protection on and off for the specified logicalfilename</firstline><content>Toggles protection on and off for the specified logicalfilename.</content></Documentation>
    <Signature name="ProtectLogicalFile" ret="" param="(varstring lfn, boolean value=TRUE)" hlen="18">ProtectLogicalFile(varstring lfn, boolean value=TRUE)</Signature><Params>
     <Param name="lfn"/>
     <Param name="value"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.dfuplusexec" inherittype="local" line="393" name="DfuPlusExec">
    <Type>function</Type>
    <Documentation>
     <firstline>The DfuPlusExec action executes the specified command line just as the DfuPLus.exe program would do</firstline><content>The DfuPlusExec action executes the specified command line just as the DfuPLus.exe program would do. This allows you to have all the functionality of the DfuPLus.exe program available within your ECL code. param cmdline The DFUPlus.exe command line to execute. The valid arguments are documented in the Client Tools manual, in the section describing the DfuPlus.exe program.</content></Documentation>
    <Signature name="DfuPlusExec" ret="" param="(varstring cmdline)" hlen="11">DfuPlusExec(varstring cmdline)</Signature><Params>
     <Param name="cmdline"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fsprayfixed" inherittype="local" line="418" name="fSprayFixed">
    <Type>function</Type>
    <Documentation>
     <param><name>sourceIP</name><desc>The IP address of the file.</desc></param><param><name>sourcePath</name><desc>The path and name of the file.</desc></param><param><name>recordsize</name><desc>The size (in bytes) of the records in the file.</desc></param><param><name>destinationGroup</name><desc>The name of the group to distribute the file across.</desc></param><param><name>destinationLogicalName</name><desc>The logical name of the file to create.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><param><name>replicate</name><desc>Whether to replicate the new file. Defaults to FALSE.</desc></param><param><name>compress</name><desc>Whether to compress the new file. Defaults to FALSE.</desc></param><param><name>failIfNoSourceFile</name><desc>If TRUE it causes a missing source file to trigger a failure. Defaults to FALSE.</desc></param><param><name>expireDays</name><desc>Number of days to auto-remove file. Default is -1, not expire.</desc></param><firstline>Sprays a file of fixed length records from a single machine and distributes it across the nodes of the destination group</firstline><content>Sprays a file of fixed length records from a single machine and distributes it across the nodes of the destination group.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fSprayFixed" ret="varstring" param="(varstring sourceIP, varstring sourcePath, integer4 recordSize, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)" hlen="21">varstring fSprayFixed(varstring sourceIP, varstring sourcePath, integer4 recordSize, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="recordSize"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.sprayfixed" inherittype="local" line="427" name="SprayFixed">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fSprayFixed, but does not return the DFU Workunit ID</firstline><content>Same as fSprayFixed, but does not return the DFU Workunit ID.</content><see>fSprayFixed</see></Documentation>
    <Signature name="SprayFixed" ret="" param="(varstring sourceIP, varstring sourcePath, integer4 recordSize, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)" hlen="10">SprayFixed(varstring sourceIP, varstring sourcePath, integer4 recordSize, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="recordSize"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fsprayvariable" inherittype="local" line="431" name="fSprayVariable">
    <Type>function</Type>
    <Signature name="fSprayVariable" ret="varstring" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\&quot;', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)" hlen="24">varstring fSprayVariable(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\"', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceCsvSeparate"/>
     <Param name="sourceCsvTerminate"/>
     <Param name="sourceCsvQuote"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="sourceCsvEscape"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="recordStructurePresent"/>
     <Param name="quotedTerminator"/>
     <Param name="encoding"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.sprayvariable" inherittype="local" line="435" name="SprayVariable">
    <Type>function</Type>
    <Signature name="SprayVariable" ret="" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\&quot;', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)" hlen="13">SprayVariable(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\"', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceCsvSeparate"/>
     <Param name="sourceCsvTerminate"/>
     <Param name="sourceCsvQuote"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="sourceCsvEscape"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="recordStructurePresent"/>
     <Param name="quotedTerminator"/>
     <Param name="encoding"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fspraydelimited" inherittype="local" line="465" name="fSprayDelimited">
    <Type>function</Type>
    <Documentation>
     <param><name>sourceIP</name><desc>The IP address of the file.</desc></param><param><name>sourcePath</name><desc>The path and name of the file.</desc></param><param><name>sourceCsvSeparate</name><desc>The character sequence which separates fields in the file.</desc></param><param><name>sourceCsvTerminate</name><desc>The character sequence which separates records in the file.</desc></param><param><name>sourceCsvQuote</name><desc>A string which can be used to delimit fields in the file.</desc></param><param><name>sourceMaxRecordSize</name><desc>The maximum size (in bytes) of the records in the file.</desc></param><param><name>destinationGroup</name><desc>The name of the group to distribute the file across.</desc></param><param><name>destinationLogicalName</name><desc>The logical name of the file to create.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><param><name>replicate</name><desc>Whether to replicate the new file. Defaults to FALSE.</desc></param><param><name>compress</name><desc>Whether to compress the new file. Defaults to FALSE.</desc></param><param><name>sourceCsvEscape</name><desc>A character that is used to escape quote characters. Defaults to none.</desc></param><param><name>failIfNoSourceFile</name><desc>If TRUE it causes a missing source file to trigger a failure. Defaults to FALSE.</desc></param><param><name>recordStructurePresent</name><desc>If TRUE derives the record structure from the header of the file.</desc></param><param><name>quotedTerminator</name><desc>Can the terminator character be included in a quoted field. Defaults to TRUE. If FALSE it allows quicker partitioning of the file (avoiding a complete file scan).</desc></param><param><name>expireDays</name><desc>Number of days to auto-remove file. Default is -1, not expire.</desc></param><firstline>Sprays a file of fixed delimited records from a single machine and distributes it across the nodes of the destination group</firstline><content>Sprays a file of fixed delimited records from a single machine and distributes it across the nodes of the destination group.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fSprayDelimited" ret="varstring" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\&quot;', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)" hlen="25">varstring fSprayDelimited(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\"', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, varstring encoding='ascii', integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceCsvSeparate"/>
     <Param name="sourceCsvTerminate"/>
     <Param name="sourceCsvQuote"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="sourceCsvEscape"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="recordStructurePresent"/>
     <Param name="quotedTerminator"/>
     <Param name="encoding"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.spraydelimited" inherittype="local" line="474" name="SprayDelimited">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fSprayDelimited, but does not return the DFU Workunit ID</firstline><content>Same as fSprayDelimited, but does not return the DFU Workunit ID.</content><see>fSprayDelimited</see></Documentation>
    <Signature name="SprayDelimited" ret="" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\&quot;', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, const varstring encoding='ascii', integer4 expireDays=-1)" hlen="14">SprayDelimited(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceCsvSeparate='\\,', varstring sourceCsvTerminate='\\n,\\r\\n', varstring sourceCsvQuote='\"', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, varstring sourceCsvEscape='', boolean failIfNoSourceFile=FALSE, boolean recordStructurePresent=FALSE, boolean quotedTerminator=TRUE, const varstring encoding='ascii', integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceCsvSeparate"/>
     <Param name="sourceCsvTerminate"/>
     <Param name="sourceCsvQuote"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="sourceCsvEscape"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="recordStructurePresent"/>
     <Param name="quotedTerminator"/>
     <Param name="encoding"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fsprayxml" inherittype="local" line="499" name="fSprayXml">
    <Type>function</Type>
    <Documentation>
     <param><name>sourceIP</name><desc>The IP address of the file.</desc></param><param><name>sourcePath</name><desc>The path and name of the file.</desc></param><param><name>sourceMaxRecordSize</name><desc>The maximum size (in bytes) of the records in the file.</desc></param><param><name>sourceRowTag</name><desc>The xml tag that is used to delimit records in the source file. (This tag cannot recursivly nest.)</desc></param><param><name>sourceEncoding</name><desc>The unicode encoding of the file. (utf8,utf8n,utf16be,utf16le,utf32be,utf32le)</desc></param><param><name>destinationGroup</name><desc>The name of the group to distribute the file across.</desc></param><param><name>destinationLogicalName</name><desc>The logical name of the file to create.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><param><name>replicate</name><desc>Whether to replicate the new file. Defaults to FALSE.</desc></param><param><name>compress</name><desc>Whether to compress the new file. Defaults to FALSE.</desc></param><param><name>failIfNoSourceFile</name><desc>If TRUE it causes a missing source file to trigger a failure. Defaults to FALSE.</desc></param><param><name>expireDays</name><desc>Number of days to auto-remove file. Default is -1, not expire.</desc></param><firstline>Sprays an xml file from a single machine and distributes it across the nodes of the destination group</firstline><content>Sprays an xml file from a single machine and distributes it across the nodes of the destination group.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fSprayXml" ret="varstring" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceRowTag, varstring sourceEncoding='utf8', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)" hlen="19">varstring fSprayXml(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceRowTag, varstring sourceEncoding='utf8', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceRowTag"/>
     <Param name="sourceEncoding"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.sprayxml" inherittype="local" line="508" name="SprayXml">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fSprayXml, but does not return the DFU Workunit ID</firstline><content>Same as fSprayXml, but does not return the DFU Workunit ID.</content><see>fSprayXml</see></Documentation>
    <Signature name="SprayXml" ret="" param="(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceRowTag, varstring sourceEncoding='utf8', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)" hlen="8">SprayXml(varstring sourceIP, varstring sourcePath, integer4 sourceMaxRecordSize=8192, varstring sourceRowTag, varstring sourceEncoding='utf8', varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean compress=FALSE, boolean failIfNoSourceFile=FALSE, integer4 expireDays=-1)</Signature><Params>
     <Param name="sourceIP"/>
     <Param name="sourcePath"/>
     <Param name="sourceMaxRecordSize"/>
     <Param name="sourceRowTag"/>
     <Param name="sourceEncoding"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="compress"/>
     <Param name="failIfNoSourceFile"/>
     <Param name="expireDays"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fdespray" inherittype="local" line="525" name="fDespray">
    <Type>function</Type>
    <Documentation>
     <param><name>logicalName</name><desc>The name of the file to despray.</desc></param><param><name>destinationIP</name><desc>The IP of the target machine.</desc></param><param><name>destinationPath</name><desc>The path of the file to create on the destination machine.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><firstline>Copies a distributed file from multiple machines, and desprays it to a single file on a single machine</firstline><content>Copies a distributed file from multiple machines, and desprays it to a single file on a single machine.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fDespray" ret="varstring" param="(varstring logicalName, varstring destinationIP, varstring destinationPath, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE)" hlen="18">varstring fDespray(varstring logicalName, varstring destinationIP, varstring destinationPath, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE)</Signature><Params>
     <Param name="logicalName"/>
     <Param name="destinationIP"/>
     <Param name="destinationPath"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.despray" inherittype="local" line="534" name="Despray">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fDespray, but does not return the DFU Workunit ID</firstline><content>Same as fDespray, but does not return the DFU Workunit ID.</content><see>fDespray</see></Documentation>
    <Signature name="Despray" ret="" param="(varstring logicalName, varstring destinationIP, varstring destinationPath, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE)" hlen="7">Despray(varstring logicalName, varstring destinationIP, varstring destinationPath, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE)</Signature><Params>
     <Param name="logicalName"/>
     <Param name="destinationIP"/>
     <Param name="destinationPath"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fcopy" inherittype="local" line="560" name="fCopy">
    <Type>function</Type>
    <Documentation>
     <param><name>sourceLogicalName</name><desc>The name of the file to despray.</desc></param><param><name>destinationGroup</name><desc>The name of the group to distribute the file across.</desc></param><param><name>destinationLogicalName</name><desc>The logical name of the file to create.</desc></param><param><name>sourceDali</name><desc>The dali that contains the source file (blank implies same dali). Defaults to same dali.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><param><name>replicate</name><desc>Should the copied file also be replicated on the destination? Defaults to FALSE</desc></param><param><name>asSuperfile</name><desc>Should the file be copied as a superfile? If TRUE and source is a superfile, then the operation creates a superfile on the target, creating sub-files as needed and only overwriting existing sub-files whose content has changed. If FALSE, a single file is created. Defaults to FALSE.</desc></param><param><name>compress</name><desc>Whether to compress the new file. Defaults to FALSE.</desc></param><param><name>forcePush</name><desc>Should the copy process be executed on the source nodes (push) or on the destination nodes (pull)? Default is to pull.</desc></param><param><name>transferBufferSize</name><desc>Overrides the size (in bytes) of the internal buffer used to copy the file. Default is 64k.</desc></param><firstline>Copies a distributed file to another distributed file</firstline><content>Copies a distributed file to another distributed file.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fCopy" ret="varstring" param="(varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, varstring sourceDali='', integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean compress=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean preserveCompression=TRUE)" hlen="15">varstring fCopy(varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, varstring sourceDali='', integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean compress=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean preserveCompression=TRUE)</Signature><Params>
     <Param name="sourceLogicalName"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="sourceDali"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="asSuperfile"/>
     <Param name="compress"/>
     <Param name="forcePush"/>
     <Param name="transferBufferSize"/>
     <Param name="preserveCompression"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.copy" inherittype="local" line="569" name="Copy">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fCopy, but does not return the DFU Workunit ID</firstline><content>Same as fCopy, but does not return the DFU Workunit ID.</content><see>fCopy</see></Documentation>
    <Signature name="Copy" ret="" param="(varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, varstring sourceDali='', integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean compress=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean preserveCompression=TRUE)" hlen="4">Copy(varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, varstring sourceDali='', integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'), integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean compress=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean preserveCompression=TRUE)</Signature><Params>
     <Param name="sourceLogicalName"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="sourceDali"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="replicate"/>
     <Param name="asSuperfile"/>
     <Param name="compress"/>
     <Param name="forcePush"/>
     <Param name="transferBufferSize"/>
     <Param name="preserveCompression"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.freplicate" inherittype="local" line="582" name="fReplicate">
    <Type>function</Type>
    <Documentation>
     <param><name>logicalName</name><desc>The name of the file to replicate.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><firstline>Ensures the specified file is replicated to its mirror copies</firstline><content>Ensures the specified file is replicated to its mirror copies.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fReplicate" ret="varstring" param="(varstring logicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="20">varstring fReplicate(varstring logicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="logicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.replicate" inherittype="local" line="591" name="Replicate">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fReplicated, but does not return the DFU Workunit ID</firstline><content>Same as fReplicated, but does not return the DFU Workunit ID.</content><see>fReplicate</see></Documentation>
    <Signature name="Replicate" ret="" param="(varstring logicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="9">Replicate(varstring logicalName, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="logicalName"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fremotepull" inherittype="local" line="619" name="fRemotePull">
    <Type>function</Type>
    <Documentation>
     <param><name>remoteEspFsURL</name><desc>The url of the remote ESP file copying service.</desc></param><param><name>sourceLogicalName</name><desc>The name of the file to despray.</desc></param><param><name>destinationGroup</name><desc>The name of the group to distribute the file across.</desc></param><param><name>destinationLogicalName</name><desc>The logical name of the file to create.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>maxConnections</name><desc>The maximum number of target nodes to write to concurrently. Defaults to 1.</desc></param><param><name>allowOverwrite</name><desc>Is it valid to overwrite an existing file of the same name? Defaults to FALSE</desc></param><param><name>replicate</name><desc>Should the copied file also be replicated on the destination? Defaults to FALSE</desc></param><param><name>asSuperfile</name><desc>Should the file be copied as a superfile? If TRUE and source is a superfile, then the operation creates a superfile on the target, creating sub-files as needed and only overwriting existing sub-files whose content has changed. If FALSE a single file is created. Defaults to FALSE.</desc></param><param><name>compress</name><desc>Whether to compress the new file. Defaults to FALSE.</desc></param><param><name>forcePush</name><desc>Should the copy process should be executed on the source nodes (push) or on the destination nodes (pull)? Default is to pull.</desc></param><param><name>transferBufferSize</name><desc>Overrides the size (in bytes) of the internal buffer used to copy the file. Default is 64k.</desc></param><param><name>wrap</name><desc>Should the fileparts be wrapped when copying to a smaller sized cluster? The default is FALSE.</desc></param><firstline>Copies a distributed file to a distributed file on remote system</firstline><content>Copies a distributed file to a distributed file on remote system. Similar to fCopy, except the copy executes remotely. Since the DFU workunit executes on the remote DFU server, the user name authentication must be the same on both systems, and the user must have rights to copy files on both systems.</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fRemotePull" ret="varstring" param="(varstring remoteEspFsURL, varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean wrap=FALSE, boolean compress=FALSE)" hlen="21">varstring fRemotePull(varstring remoteEspFsURL, varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean wrap=FALSE, boolean compress=FALSE)</Signature><Params>
     <Param name="remoteEspFsURL"/>
     <Param name="sourceLogicalName"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="Replicate"/>
     <Param name="asSuperfile"/>
     <Param name="forcePush"/>
     <Param name="transferBufferSize"/>
     <Param name="wrap"/>
     <Param name="compress"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.remotepull" inherittype="local" line="628" name="RemotePull">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fRemotePull, but does not return the DFU Workunit ID</firstline><content>Same as fRemotePull, but does not return the DFU Workunit ID.</content><see>fRemotePull</see></Documentation>
    <Signature name="RemotePull" ret="" param="(varstring remoteEspFsURL, varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean wrap=FALSE, boolean compress=FALSE)" hlen="10">RemotePull(varstring remoteEspFsURL, varstring sourceLogicalName, varstring destinationGroup, varstring destinationLogicalName, integer4 timeOut=-1, integer4 maxConnections=-1, boolean allowOverwrite=FALSE, boolean replicate=FALSE, boolean asSuperfile=FALSE, boolean forcePush=FALSE, integer4 transferBufferSize=0, boolean wrap=FALSE, boolean compress=FALSE)</Signature><Params>
     <Param name="remoteEspFsURL"/>
     <Param name="sourceLogicalName"/>
     <Param name="destinationGroup"/>
     <Param name="destinationLogicalName"/>
     <Param name="timeOut"/>
     <Param name="maxConnections"/>
     <Param name="allowOverwrite"/>
     <Param name="Replicate"/>
     <Param name="asSuperfile"/>
     <Param name="forcePush"/>
     <Param name="transferBufferSize"/>
     <Param name="wrap"/>
     <Param name="compress"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fmonitorlogicalfilename" inherittype="local" line="646" name="fMonitorLogicalFileName">
    <Type>function</Type>
    <Documentation>
     <param><name>eventToFire</name><desc>The user-defined name of the event to fire when the filename appears. This value is used as the first parameter to the EVENT function.</desc></param><param><name>name</name><desc>The name of the logical file to monitor. This may contain wildcard characters ( * and ?)</desc></param><param><name>shotCount</name><desc>The number of times to generate the event before the monitoring job completes. A value of -1 indicates the monitoring job continues until manually aborted. The default is 1.</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><firstline>Creates a file monitor job in the DFU Server</firstline><content>Creates a file monitor job in the DFU Server. If an appropriately named file arrives in this interval it will fire the event with the name of the triggering object as the event subtype (see the EVENT function).</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fMonitorLogicalFileName" ret="varstring" param="(varstring eventToFire, varstring name, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="33">varstring fMonitorLogicalFileName(varstring eventToFire, varstring name, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="eventToFire"/>
     <Param name="name"/>
     <Param name="shotCount"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.monitorlogicalfilename" inherittype="local" line="655" name="MonitorLogicalFileName">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fMonitorLogicalFileName, but does not return the DFU Workunit ID</firstline><content>Same as fMonitorLogicalFileName, but does not return the DFU Workunit ID.</content><see>fMonitorLogicalFileName</see></Documentation>
    <Signature name="MonitorLogicalFileName" ret="" param="(varstring eventToFire, varstring name, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="22">MonitorLogicalFileName(varstring eventToFire, varstring name, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="eventToFire"/>
     <Param name="name"/>
     <Param name="shotCount"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.fmonitorfile" inherittype="local" line="674" name="fMonitorFile">
    <Type>function</Type>
    <Documentation>
     <param><name>eventToFire</name><desc>The user-defined name of the event to fire when the filename appears. This value is used as the first parameter to the EVENT function.</desc></param><param><name>ip</name><desc>The the IP address for the file to monitor. This may be omitted if the filename parameter contains a complete URL.</desc></param><param><name>filename</name><desc>The full path of the file(s) to monitor. This may contain wildcard characters ( * and ?)</desc></param><param><name>subDirs</name><desc>Whether to include files in sub-directories (when the filename contains wildcards). Defaults to FALSE.</desc></param><param><name>shotCount</name><desc>The number of times to generate the event before the monitoring job completes. A value of -1 indicates the monitoring job continues until manually aborted. The default is 1.</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><firstline>Creates a file monitor job in the DFU Server</firstline><content>Creates a file monitor job in the DFU Server. If an appropriately named file arrives in this interval it will fire the event with the name of the triggering object as the event subtype (see the EVENT function).</content><return>The DFU workunit id for the job.</return></Documentation>
    <Signature name="fMonitorFile" ret="varstring" param="(varstring eventToFire, varstring ip, varstring filename, boolean subDirs=FALSE, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="22">varstring fMonitorFile(varstring eventToFire, varstring ip, varstring filename, boolean subDirs=FALSE, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="eventToFire"/>
     <Param name="ip"/>
     <Param name="filename"/>
     <Param name="subDirs"/>
     <Param name="shotCount"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.monitorfile" inherittype="local" line="683" name="MonitorFile">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fMonitorFile, but does not return the DFU Workunit ID</firstline><content>Same as fMonitorFile, but does not return the DFU Workunit ID.</content><see>fMonitorFile</see></Documentation>
    <Signature name="MonitorFile" ret="" param="(varstring eventToFire, varstring ip, varstring filename, boolean subdirs=FALSE, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="11">MonitorFile(varstring eventToFire, varstring ip, varstring filename, boolean subdirs=FALSE, integer4 shotCount=1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="eventToFire"/>
     <Param name="ip"/>
     <Param name="filename"/>
     <Param name="subdirs"/>
     <Param name="shotCount"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.waitdfuworkunit" inherittype="local" line="696" name="WaitDfuWorkunit">
    <Type>function</Type>
    <Documentation>
     <param><name>wuid</name><desc>The dfu wfid to wait for.</desc></param><param><name>timeOut</name><desc>The time in ms to wait for the operation to complete. A value of 0 causes the call to return immediately. Defaults to no timeout (-1).</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><firstline>Waits for the specified DFU workunit to finish</firstline><content>Waits for the specified DFU workunit to finish.</content><return>A string containing the final status string of the DFU workunit.</return></Documentation>
    <Signature name="WaitDfuWorkunit" ret="varstring" param="(varstring wuid, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="25">varstring WaitDfuWorkunit(varstring wuid, integer4 timeOut=-1, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="wuid"/>
     <Param name="timeOut"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.abortdfuworkunit" inherittype="local" line="706" name="AbortDfuWorkunit">
    <Type>function</Type>
    <Documentation>
     <param><name>wuid</name><desc>The dfu wfid to abort.</desc></param><param><name>espServerIpPort</name><desc>The url of the ESP file copying service. Defaults to the value of ws_fs_server in the environment.</desc></param><firstline>Aborts the specified DFU workunit</firstline><content>Aborts the specified DFU workunit.</content></Documentation>
    <Signature name="AbortDfuWorkunit" ret="" param="(varstring wuid, varstring espServerIpPort=GETENV('ws_fs_server'))" hlen="16">AbortDfuWorkunit(varstring wuid, varstring espServerIpPort=GETENV('ws_fs_server'))</Signature><Params>
     <Param name="wuid"/>
     <Param name="espServerIpPort"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.createsuperfile" inherittype="local" line="720" name="CreateSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>sequentialParts</name><desc>Whether the sub-files must be sequentially ordered. Default to FALSE.</desc></param><param><name>allowExist</name><desc>Indicating whether to post an error if the superfile already exists. If TRUE, no error is posted. Defaults to FALSE.</desc></param><firstline>Creates an empty superfile</firstline><content>Creates an empty superfile. This function is not included in a superfile transaction.</content></Documentation>
    <Signature name="CreateSuperFile" ret="" param="(varstring superName, boolean sequentialParts=FALSE, boolean allowExist=FALSE)" hlen="15">CreateSuperFile(varstring superName, boolean sequentialParts=FALSE, boolean allowExist=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="sequentialParts"/>
     <Param name="allowExist"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.superfileexists" inherittype="local" line="732" name="SuperFileExists">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><firstline>Checks if the specified filename is present in the Distributed File Utility (DFU) and is a SuperFile</firstline><content>Checks if the specified filename is present in the Distributed File Utility (DFU) and is a SuperFile.</content><return>Whether the file exists.</return><see>FileExists</see></Documentation>
    <Signature name="SuperFileExists" ret="boolean" param="(varstring superName)" hlen="23">boolean SuperFileExists(varstring superName)</Signature><Params>
     <Param name="superName"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.deletesuperfile" inherittype="local" line="743" name="DeleteSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><firstline>Deletes the superfile</firstline><content>Deletes the superfile.</content><see>FileExists</see></Documentation>
    <Signature name="DeleteSuperFile" ret="" param="(varstring superName, boolean deletesub=FALSE)" hlen="15">DeleteSuperFile(varstring superName, boolean deletesub=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="deletesub"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.getsuperfilesubcount" inherittype="local" line="753" name="GetSuperFileSubCount">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><firstline>Returns the number of sub-files contained within a superfile</firstline><content>Returns the number of sub-files contained within a superfile.</content><return>The number of sub-files within the superfile.</return></Documentation>
    <Signature name="GetSuperFileSubCount" ret="unsigned4" param="(varstring superName)" hlen="30">unsigned4 GetSuperFileSubCount(varstring superName)</Signature><Params>
     <Param name="superName"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.getsuperfilesubname" inherittype="local" line="765" name="GetSuperFileSubName">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>fileNum</name><desc>The 1-based position of the sub-file to return the name of.</desc></param><param><name>absPath</name><desc>Whether to prepend '~' to the name of the resulting logical file name.</desc></param><firstline>Returns the name of the Nth sub-file within a superfile</firstline><content>Returns the name of the Nth sub-file within a superfile.</content><return>The logical name of the selected sub-file.</return></Documentation>
    <Signature name="GetSuperFileSubName" ret="varstring" param="(varstring superName, unsigned4 fileNum, boolean absPath=FALSE)" hlen="29">varstring GetSuperFileSubName(varstring superName, unsigned4 fileNum, boolean absPath=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="fileNum"/>
     <Param name="absPath"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.findsuperfilesubname" inherittype="local" line="776" name="FindSuperFileSubName">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>subName</name><desc>The logical name of the sub-file.</desc></param><firstline>Returns the position of a file within a superfile</firstline><content>Returns the position of a file within a superfile.</content><return>The 1-based position of the sub-file within the superfile.</return></Documentation>
    <Signature name="FindSuperFileSubName" ret="unsigned4" param="(varstring superName, varstring subName)" hlen="30">unsigned4 FindSuperFileSubName(varstring superName, varstring subName)</Signature><Params>
     <Param name="superName"/>
     <Param name="subName"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.startsuperfiletransaction" inherittype="local" line="784" name="StartSuperFileTransaction">
    <Type>function</Type>
    <Documentation>
     <firstline>Starts a superfile transaction</firstline><content>Starts a superfile transaction. All superfile operations within the transaction will either be executed atomically or rolled back when the transaction is finished.</content></Documentation>
    <Signature name="StartSuperFileTransaction" ret="" param="()" hlen="25">StartSuperFileTransaction()</Signature><Params/>
   </Definition>
   <Definition exported="1" fullname="file.addsuperfile" inherittype="local" line="797" name="AddSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>subName</name><desc>The name of the logical file to add.</desc></param><param><name>atPos</name><desc>The position to add the sub-file, or 0 to append. Defaults to 0.</desc></param><param><name>addContents</name><desc>Controls whether adding a superfile adds the superfile, or its contents. Defaults to FALSE (do not expand).</desc></param><param><name>strict</name><desc>Check addContents only if subName is a superfile, and ensure superfiles exist.</desc></param><firstline>Adds a file to a superfile</firstline><content>Adds a file to a superfile.</content></Documentation>
    <Signature name="AddSuperFile" ret="" param="(varstring superName, varstring subName, unsigned4 atPos=0, boolean addContents=FALSE, boolean strict=FALSE)" hlen="12">AddSuperFile(varstring superName, varstring subName, unsigned4 atPos=0, boolean addContents=FALSE, boolean strict=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="subName"/>
     <Param name="atPos"/>
     <Param name="addContents"/>
     <Param name="strict"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.removesuperfile" inherittype="local" line="809" name="RemoveSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>subName</name><desc>The name of the sub-file to remove.</desc></param><param><name>del</name><desc>Indicates whether the sub-file should also be removed from the disk. Defaults to FALSE.</desc></param><param><name>removeContents</name><desc>Controls whether the contents of a sub-file which is a superfile should be recursively removed. Defaults to FALSE.</desc></param><firstline>Removes a sub-file from a superfile</firstline><content>Removes a sub-file from a superfile.</content></Documentation>
    <Signature name="RemoveSuperFile" ret="" param="(varstring superName, varstring subName, boolean del=FALSE, boolean removeContents=FALSE)" hlen="15">RemoveSuperFile(varstring superName, varstring subName, boolean del=FALSE, boolean removeContents=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="subName"/>
     <Param name="del"/>
     <Param name="removeContents"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.clearsuperfile" inherittype="local" line="819" name="ClearSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>del</name><desc>Indicates whether the sub-files should also be removed from the disk. Defaults to FALSE.</desc></param><firstline>Removes all sub-files from a superfile</firstline><content>Removes all sub-files from a superfile.</content></Documentation>
    <Signature name="ClearSuperFile" ret="" param="(varstring superName, boolean del=FALSE)" hlen="14">ClearSuperFile(varstring superName, boolean del=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="del"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.removeownedsubfiles" inherittype="local" line="829" name="RemoveOwnedSubFiles">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><firstline>Removes all soley-owned sub-files from a superfile</firstline><content>Removes all soley-owned sub-files from a superfile. If a sub-file is also contained within another superfile then it is retained.</content></Documentation>
    <Signature name="RemoveOwnedSubFiles" ret="" param="(varstring superName, boolean del=FALSE)" hlen="19">RemoveOwnedSubFiles(varstring superName, boolean del=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="del"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.deleteownedsubfiles" inherittype="local" line="838" name="DeleteOwnedSubFiles">
    <Type>function</Type>
    <Documentation>
     <firstline>Legacy version of RemoveOwnedSubFiles which was incorrectly named in a previous version</firstline><content>Legacy version of RemoveOwnedSubFiles which was incorrectly named in a previous version.</content><see>RemoveOwnedSubFIles</see></Documentation>
    <Signature name="DeleteOwnedSubFiles" ret="" param="(varstring superName)" hlen="19">DeleteOwnedSubFiles(varstring superName)</Signature><Params>
     <Param name="superName"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.swapsuperfile" inherittype="local" line="848" name="SwapSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName1</name><desc>The logical name of the first superfile.</desc></param><param><name>superName2</name><desc>The logical name of the second superfile.</desc></param><firstline>Swap the contents of two superfiles</firstline><content>Swap the contents of two superfiles.</content></Documentation>
    <Signature name="SwapSuperFile" ret="" param="(varstring superName1, varstring superName2)" hlen="13">SwapSuperFile(varstring superName1, varstring superName2)</Signature><Params>
     <Param name="superName1"/>
     <Param name="superName2"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.replacesuperfile" inherittype="local" line="859" name="ReplaceSuperFile">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>oldSubFile</name><desc>The logical name of the sub-file to remove.</desc></param><param><name>newSubFile</name><desc>The logical name of the sub-file to replace within the superfile.</desc></param><firstline>Removes a sub-file from a superfile and replaces it with another</firstline><content>Removes a sub-file from a superfile and replaces it with another.</content></Documentation>
    <Signature name="ReplaceSuperFile" ret="" param="(varstring superName, varstring oldSubFile, varstring newSubFile)" hlen="16">ReplaceSuperFile(varstring superName, varstring oldSubFile, varstring newSubFile)</Signature><Params>
     <Param name="superName"/>
     <Param name="oldSubFile"/>
     <Param name="newSubFile"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.finishsuperfiletransaction" inherittype="local" line="867" name="FinishSuperFileTransaction">
    <Type>function</Type>
    <Documentation>
     <firstline>Finishes a superfile transaction</firstline><content>Finishes a superfile transaction. This executes all the operations since the matching StartSuperFileTransaction(). If there are any errors, then all of the operations are rolled back.</content></Documentation>
    <Signature name="FinishSuperFileTransaction" ret="" param="(boolean rollback=FALSE)" hlen="26">FinishSuperFileTransaction(boolean rollback=FALSE)</Signature><Params>
     <Param name="rollback"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.superfilecontents" inherittype="local" line="878" name="SuperFileContents">
    <Type>function</Type>
    <Documentation>
     <param><name>superName</name><desc>The logical name of the superfile.</desc></param><param><name>recurse</name><desc>Should the contents of child-superfiles be expanded. Default is FALSE.</desc></param><firstline>Returns the list of sub-files contained within a superfile</firstline><content>Returns the list of sub-files contained within a superfile.</content><return>A dataset containing the names of the sub-files.</return></Documentation>
    <Signature name="SuperFileContents" ret="dataset(FsLogicalFileNameRecord)" param="(varstring superName, boolean recurse=FALSE)" hlen="50">dataset(FsLogicalFileNameRecord) SuperFileContents(varstring superName, boolean recurse=FALSE)</Signature><Params>
     <Param name="superName"/>
     <Param name="recurse"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.logicalfilesuperowners" inherittype="local" line="888" name="LogicalFileSuperOwners">
    <Type>function</Type>
    <Documentation>
     <param><name>name</name><desc>The name of the logical file.</desc></param><firstline>Returns the list of superfiles that a logical file is contained within</firstline><content>Returns the list of superfiles that a logical file is contained within.</content><return>A dataset containing the names of the superfiles.</return></Documentation>
    <Signature name="LogicalFileSuperOwners" ret="dataset(FsLogicalFileNameRecord)" param="(varstring name)" hlen="55">dataset(FsLogicalFileNameRecord) LogicalFileSuperOwners(varstring name)</Signature><Params>
     <Param name="name"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.logicalfilesupersublist" inherittype="local" line="897" name="LogicalFileSuperSubList">
    <Type>function</Type>
    <Documentation>
     <firstline>Returns the list of all the superfiles in the system and their component sub-files</firstline><content>Returns the list of all the superfiles in the system and their component sub-files.</content><return>A dataset containing pairs of superName,subName for each component file.</return></Documentation>
    <Signature name="LogicalFileSuperSubList" ret="dataset(FsLogicalSuperSubRecord)" param="()" hlen="56">dataset(FsLogicalSuperSubRecord) LogicalFileSuperSubList()</Signature><Params/>
   </Definition>
   <Definition exported="1" fullname="file.fpromotesuperfilelist" inherittype="local" line="915" name="fPromoteSuperFileList">
    <Type>function</Type>
    <Documentation>
     <param><name>superNames</name><desc>A set of the names of the superfiles to act on. Any that do not exist will be created. The contents of each superfile will be moved to the next in the list.</desc></param><param><name>addHead</name><desc>A string containing a comma-delimited list of logical file names to add to the first superfile after the promotion process is complete. Defaults to ''.</desc></param><param><name>delTail</name><desc>Indicates whether to physically delete the contents moved out of the last superfile. The default is FALSE.</desc></param><param><name>createOnlyOne</name><desc>Specifies whether to only create a single superfile (truncate the list at the first non-existent superfile). The default is FALSE.</desc></param><param><name>reverse</name><desc>Reverse the order of processing the superfiles list, effectively 'demoting' instead of 'promoting' the sub-files. The default is FALSE.</desc></param><firstline>Moves the sub-files from the first entry in the list of superfiles to the next in the list, repeating the process through the list of superfiles</firstline><content>Moves the sub-files from the first entry in the list of superfiles to the next in the list, repeating the process through the list of superfiles.</content><return>A string containing a comma separated list of the previous sub-file contents of the emptied superfile.</return></Documentation>
    <Signature name="fPromoteSuperFileList" ret="varstring" param="(set of varstring superNames, varstring addHead='', boolean delTail=FALSE, boolean createOnlyOne=FALSE, boolean reverse=FALSE)" hlen="31">varstring fPromoteSuperFileList(set of varstring superNames, varstring addHead='', boolean delTail=FALSE, boolean createOnlyOne=FALSE, boolean reverse=FALSE)</Signature><Params>
     <Param name="superNames"/>
     <Param name="addHead"/>
     <Param name="delTail"/>
     <Param name="createOnlyOne"/>
     <Param name="reverse"/>
    </Params>
   </Definition>
   <Definition exported="1" fullname="file.promotesuperfilelist" inherittype="local" line="924" name="PromoteSuperFileList">
    <Type>function</Type>
    <Documentation>
     <firstline>Same as fPromoteSuperFileList, but does not return the DFU Workunit ID</firstline><content>Same as fPromoteSuperFileList, but does not return the DFU Workunit ID.</content><see>fPromoteSuperFileList</see></Documentation>
    <Signature name="PromoteSuperFileList" ret="" param="(set of varstring superNames, varstring addHead='', boolean delTail=FALSE, boolean createOnlyOne=FALSE, boolean reverse=FALSE)" hlen="20">PromoteSuperFileList(set of varstring superNames, varstring addHead='', boolean delTail=FALSE, boolean createOnlyOne=FALSE, boolean reverse=FALSE)</Signature><Params>
     <Param name="superNames"/>
     <Param name="addHead"/>
     <Param name="delTail"/>
     <Param name="createOnlyOne"/>
     <Param name="reverse"/>
    </Params>
   </Definition>
   <Signature name="File" ret="" param="" hlen="4">File</Signature><Parents/>
  </Definition>
 <Documentation><content> </content></Documentation></Source>
</Meta>
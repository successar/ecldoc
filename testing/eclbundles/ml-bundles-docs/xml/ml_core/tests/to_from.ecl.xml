<?xml version='1.0' encoding='UTF-8'?>
<Meta>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Query sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl"/>
 <Source name="ML_Core.Tests.to_from" sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" target="to_from.ecl.xml">
  <Import body="0" end="7" fullname="ML_Core" inherit_type="local" line="1" name="ML_Core" ref="ml_core" start="7" target="../pkg.toc.xml">
   <Type>attribute</Type>
  </Import>
  <Import body="0" end="30" fullname="ML_Core.Types" inherit_type="local" line="2" name="Types" ref="ml_core.types" start="30" target="../types.ecl.xml">
   <Type>attribute</Type>
  </Import>
  <Definition body="61" end="197" fullname="ml_core.tests.work1" inherit_type="local" line="4" name="Work1" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="53">
   <Type>record</Type>
   <Field name="num_2"/>
   <Field name="wi_f"/>
   <Field name="num_1"/>
   <Field name="id_f"/>
   <Field name="float_1"/>
   <Field name="float_2"/>
   <Signature pre="" post="" name="Work1">Work1</Signature><Field name="str_1"/>
  </Definition>
  <Definition body="241" end="428" fullname="ml_core.tests.gen_work1" inherit_type="local" line="13" name="gen_work1" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="198">
   <Type>transform</Type>
   <Params>
    <Param name="c"/>
    <Param name="wi"/>
   </Params>
   <Signature pre="" post="" name="Work1 gen_work1(UNSIGNED c, UNSIGNED wi)">Work1 gen_work1(UNSIGNED c, UNSIGNED wi)</Signature><Return>work1</Return>
  </Definition>
  <Definition body="434" end="512" fullname="ml_core.tests.ds" inherit_type="local" line="22" name="ds" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="429">
   <Signature pre="" post="" name="ds">ds</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="525" end="558" fullname="ml_core.tests.test_data" inherit_type="local" line="24" name="test_data" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="513">
   <Signature pre="" post="" name="test_data">test_data</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="710" end="749" fullname="ml_core.tests.t1a" inherit_type="local" line="30" name="t1a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="704">
   <Signature pre="" post="" name="t1a">t1a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="244" end="299" fullname="ml_core.tests.__dinprep__37__" inherit_type="local" line="31" name="__dInPrep__37__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__37__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resultin</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="244" end="299" fullname="ml_core.tests.__dinprep__3__" inherit_type="local" line="31" name="__dInPrep__3__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__3__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resultin</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="756" end="799" fullname="ml_core.tests.t1b" inherit_type="local" line="31" name="t1b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="750">
   <Signature pre="" post="" name="t1b">t1b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="806" end="857" fullname="ml_core.tests.t1c" inherit_type="local" line="32" name="t1c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="800">
   <Signature pre="" post="" name="t1c">t1c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="864" end="913" fullname="ml_core.tests.t1d" inherit_type="local" line="33" name="t1d" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="858">
   <Signature pre="" post="" name="t1d">t1d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__13__" inherit_type="local" line="36" name="__dTmp__13__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__13__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__18__" inherit_type="local" line="36" name="__dTmp__18__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__18__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__23__" inherit_type="local" line="36" name="__dTmp__23__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__23__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__28__" inherit_type="local" line="36" name="__dTmp__28__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__28__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__33__" inherit_type="local" line="36" name="__dTmp__33__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__33__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="452" end="822" fullname="ml_core.tests.__dtmp__8__" inherit_type="local" line="36" name="__dTmp__8__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dTmp__8__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1031" end="1071" fullname="ml_core.tests.t2a" inherit_type="local" line="38" name="t2a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1025">
   <Signature pre="" post="" name="t2a">t2a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1078" end="1122" fullname="ml_core.tests.t2b" inherit_type="local" line="39" name="t2b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1072">
   <Signature pre="" post="" name="t2b">t2b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1129" end="1167" fullname="ml_core.tests.t2c" inherit_type="local" line="40" name="t2c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1123">
   <Signature pre="" post="" name="t2c">t2c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__12__" inherit_type="local" line="43" name="__dInPrep__12__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__12__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__17__" inherit_type="local" line="43" name="__dInPrep__17__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__17__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__22__" inherit_type="local" line="43" name="__dInPrep__22__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__22__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__27__" inherit_type="local" line="43" name="__dInPrep__27__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__27__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__32__" inherit_type="local" line="43" name="__dInPrep__32__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__32__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="838" end="1605" fullname="ml_core.tests.__dinprep__7__" inherit_type="local" line="43" name="__dInPrep__7__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dInPrep__7__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          Thi</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1306" end="1347" fullname="ml_core.tests.t3a" inherit_type="local" line="45" name="t3a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1300">
   <Signature pre="" post="" name="t3a">t3a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1354" end="1399" fullname="ml_core.tests.t3b" inherit_type="local" line="46" name="t3b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1348">
   <Signature pre="" post="" name="t3b">t3b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1406" end="1445" fullname="ml_core.tests.t3c" inherit_type="local" line="47" name="t3c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1400">
   <Signature pre="" post="" name="t3c">t3c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1560" end="1595" fullname="ml_core.tests.t4a" inherit_type="local" line="52" name="t4a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1554">
   <Signature pre="" post="" name="t4a">t4a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1602" end="1641" fullname="ml_core.tests.t4b" inherit_type="local" line="53" name="t4b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1596">
   <Signature pre="" post="" name="t4b">t4b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1648" end="1681" fullname="ml_core.tests.t4c" inherit_type="local" line="54" name="t4c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1642">
   <Signature pre="" post="" name="t4c">t4c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1827" end="1870" fullname="ml_core.tests.t5a" inherit_type="local" line="59" name="t5a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1821">
   <Signature pre="" post="" name="t5a">t5a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1877" end="1924" fullname="ml_core.tests.t5b" inherit_type="local" line="60" name="t5b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1871">
   <Signature pre="" post="" name="t5b">t5b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="1931" end="1972" fullname="ml_core.tests.t5c" inherit_type="local" line="61" name="t5c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="1925">
   <Signature pre="" post="" name="t5c">t5c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2146" end="2184" fullname="ml_core.tests.t6a" inherit_type="local" line="67" name="t6a" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="2140">
   <Signature pre="" post="" name="t6a">t6a</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2191" end="2233" fullname="ml_core.tests.t6b" inherit_type="local" line="68" name="t6b" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="2185">
   <Signature pre="" post="" name="t6b">t6b</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2240" end="2288" fullname="ml_core.tests.t6c" inherit_type="local" line="69" name="t6c" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="2234">
   <Signature pre="" post="" name="t6c">t6c</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2295" end="2345" fullname="ml_core.tests.t6d" inherit_type="local" line="70" name="t6d" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="2289">
   <Signature pre="" post="" name="t6d">t6d</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__14__" inherit_type="local" line="81" name="__dIDs__14__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__14__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__19__" inherit_type="local" line="81" name="__dIDs__19__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__19__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__24__" inherit_type="local" line="81" name="__dIDs__24__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__24__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__29__" inherit_type="local" line="81" name="__dIDs__29__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__29__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__34__" inherit_type="local" line="81" name="__dIDs__34__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__34__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__38__" inherit_type="local" line="81" name="__dIDs__38__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__38__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__4__" inherit_type="local" line="81" name="__dIDs__4__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__4__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2583" end="2716" fullname="ml_core.tests.__dids__9__" inherit_type="local" line="81" name="__dIDs__9__" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="__dIDs__9__">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds1_w_map" inherit_type="local" line="82" name="ds1_w_map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds1_w_map">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds1_wo_map" inherit_type="local" line="82" name="ds1_wo_map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds1_wo_map">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds2" inherit_type="local" line="82" name="ds2" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds2">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds3" inherit_type="local" line="82" name="ds3" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds3">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds4" inherit_type="local" line="82" name="ds4" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds4">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds5" inherit_type="local" line="82" name="ds5" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds5">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds6_w_map" inherit_type="local" line="82" name="ds6_w_map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds6_w_map">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2725" end="2854" fullname="ml_core.tests.ds6_wo_map" inherit_type="local" line="82" name="ds6_wo_map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/FromField.ecl" start="1">
   <Signature pre="" post="" name="ds6_wo_map">/---------------------------------------------------------------------------
// Macro to reconstitute an original matrix from a NumericField-formatted
// dataset.  In the simplest case, the assumption is that the field order
// of the resulting table is in line with the field numbers in the input
// dataset, with the ID field as the first field.  If a field mapping is
// specified, this order can be re-arranged.
//   dIn  : The name of the input dataset in NumericField format
//   lOut : The name of the resulting layout the data should be in
//   dOut : The name of the resulting dataset
//   dMap : [OPTIONAL] If the user customized the fields used in the ToField
//          process, they should include the mapping table that was created
//          automatically by ToField here so the fields map back properly.
//          This will be named NF_map, where NF is the name of the
//          NumericField table that was created by ToField.
//  Examples (used to reconstitute the ToField examples):
//    ML.FromField(dMatrix,lOrig,dResults);
//    ML.FromField(dMatrix,lOrig,dResults,dOrigData_Map);
//
// IMPORTANT NOTE: If fields in lOut were disregarded by the ToField macro
// during the creation of the NumericField table, those fields WILL NOT be
// reconstituted by this macro.  They will be left blank or zero.
//---------------------------------------------------------------------------
EXPORT FromField(dIn,lOut,dOut,dMap=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // If a mapping table was specified, we need to join it to the input data
  // to marry the field number to the field name.
  #UNIQUENAME(id)
  #UNIQUENAME(wi)
  #UNIQUENAME(dInPrep)
  #IF(#TEXT(dMap)='')
    %dInPrep%:=TABLE(dIn,{UNSIGNED %id%:=id;UNSIGNED %wi%:=wi; dIn;});
    // Variable to keep track of which field number we are on
    #DECLARE(iUnPivotLoop) #SET(iUnPivotLoop,0)
  #ELSE
    #UNIQUENAME(dTmp)
    %dTmp%:=JOIN(dIn,dMap((UNSIGNED)assigned_name&gt;0),
                LEFT.number=(UNSIGNED)RIGHT.assigned_name,
                TRANSFORM({UNSIGNED %id%;UNSIGNED %wi%;RECORDOF(dIn) OR RECORDOF(dMap);},
                          SELF.%id%:=LEFT.id;
                          SELF.%wi%:=LEFT.wi;
                          SELF:=LEFT;SELF:=RIGHT;),
                LOOKUP,LEFT OUTER);
    %dInPrep%:=%dTmp%+PROJECT(DEDUP(dIn,id),
                              TRANSFORM(RECORDOF(%dTmp%),
                              SELF.%id%:=LEFT.id;
                              SELF.%wi%:=LEFT.wi;
                              SELF.orig_name:=dMap(assigned_name='ID')[1].orig_name;
                              SELF.value:=LEFT.id;
                              SELF:=LEFT;SELF:=[]))
                     +PROJECT(DEDUP(dIn,id),</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="34" end="109" fullname="ml_core.tests.nf_ds1_toname" inherit_type="local" line="97" name="nf_ds1_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds1_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="34" end="110" fullname="ml_core.tests.nf_ds2_toname" inherit_type="local" line="97" name="nf_ds2_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds2_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="34" end="70" fullname="ml_core.tests.nf_ds3_toname" inherit_type="local" line="97" name="nf_ds3_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds3_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="34" end="110" fullname="ml_core.tests.nf_ds4_toname" inherit_type="local" line="97" name="nf_ds4_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds4_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="34" end="70" fullname="ml_core.tests.nf_ds5_toname" inherit_type="local" line="97" name="nf_ds5_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds5_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="34" end="98" fullname="ml_core.tests.nf_ds6_toname" inherit_type="local" line="97" name="nf_ds6_ToName" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds6_ToName">//IMPORT $.Types AS Types;
//-----</Signature><Params>
    <Param name="i"/>
   </Params>
  </Definition>
  <Definition body="36" end="110" fullname="ml_core.tests.nf_ds1_tonumber" inherit_type="local" line="99" name="nf_ds1_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds1_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="36" end="111" fullname="ml_core.tests.nf_ds2_tonumber" inherit_type="local" line="99" name="nf_ds2_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds2_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="36" end="71" fullname="ml_core.tests.nf_ds3_tonumber" inherit_type="local" line="99" name="nf_ds3_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds3_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="36" end="111" fullname="ml_core.tests.nf_ds4_tonumber" inherit_type="local" line="99" name="nf_ds4_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds4_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="36" end="71" fullname="ml_core.tests.nf_ds5_tonumber" inherit_type="local" line="99" name="nf_ds5_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds5_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="36" end="99" fullname="ml_core.tests.nf_ds6_tonumber" inherit_type="local" line="99" name="nf_ds6_ToNumber" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Type>function</Type>
   <Signature pre="" post="" name="nf_ds6_ToNumber">//IMPORT $.Types AS Types;
//-------</Signature><Params>
    <Param name="s"/>
   </Params>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds1" inherit_type="local" line="101" name="nf_ds1" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds1">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds2" inherit_type="local" line="101" name="nf_ds2" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds2">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds3" inherit_type="local" line="101" name="nf_ds3" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds3">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds4" inherit_type="local" line="101" name="nf_ds4" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds4">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds5" inherit_type="local" line="101" name="nf_ds5" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds5">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2862" end="3137" fullname="ml_core.tests.nf_ds6" inherit_type="local" line="101" name="nf_ds6" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="1">
   <Signature pre="" post="" name="nf_ds6">/IMPORT $.Types AS Types;
//---------------------------------------------------------------------------
// Macro takes a matrix dataset, with each row contianing an ID and one or
// more axis fields containing numeric values, and expands it into the
// NumericField format used by ML.
//
//   dIn       : The name of the input dataset
//   dOut      : The name of the resulting dataset
//   idfield   : [OPTIONAL] The name of the field that contains the UID for
//               each row.  If omitted, it is assumed to be the first field.
//   wifield   : [OPTIOPNAL] The name of the field that contains the
//               work item value.  A constant is used if the field name
//               is not supplied.
//   wivalue   : [OPTIONAL} The constant value to use for work item.
//               The value 1 is used if not supplied.
//   datafields: [OPTIONAL] A STRING contianing a comma-delimited list of the
//               fields to be treated as axes.  If omitted, all numeric
//               fields that are not the UID will be treated as axes.
//               NOTE: idfield defaults to the first field in the table, so
//               if that field is specified as an axis field, then the user
//               should be sure to specify a value in the idfield param.
//
//  Along with creating the NumericField table, this macro produces two
//  simple functions to assist the user in mapping the field names to their
//  corresponding numbers.  These are "STRING dOut_ToName(UNSIGNED)" and
//  "UNSIGNED dOut_ToNumber(STRING)", where the "dOut" portion of the function
//  name is the name passed into that parameter of the macro.
//
//  The macro also produces a mapping table named "dOut_Map", again where
//  "dOut" refers to the parameter, that contains a table of the field
//  mappings
//
//  Examples:
//    ML.ToField(dOrig,dMatrix);
//    ML.ToField(dOrig,dMatrix,myid,'field5,field7,field10');
//    dMatrix_ToName(2);  // returns 'field7'
//    dMatrix_ToNumber('field10'); // returns 3
//    dMatrix_Map; // returns the mapping table of field name to number
//---------------------------------------------------------------------------
EXPORT ToField(dIn,dOut,idfield='', wifield='', wivalue='',datafields=''):=MACRO
  LOADXML('&lt;xml/&gt;');
  // Variable to contain the name if the field that maps to "wi", or the value
  #DECLARE(use_for_wi);
  #IF(#TEXT(wivalue) = '')
    #SET(use_for_wi, 1);
  #ELSE
    #SET(use_for_wi, #TEXT(wivalue));
  #END
  // Variable to contain the name of the field that maps to "id"
  #DECLARE(foundidfield); #SET(foundidfield,#TEXT(idfield));
  // Contains a comma-delimited list of the fields that will be used as axes,
  // beginning with "COUNTER" so it can be #EXPANDED into a CHOOSE call
  // during normalization
  #DECLARE(normlist); #SET(normlist,'COUNTER');
  // Count of the fields that become</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds1_map" inherit_type="local" line="107" name="nf_ds1_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds1_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds2_map" inherit_type="local" line="107" name="nf_ds2_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds2_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds3_map" inherit_type="local" line="107" name="nf_ds3_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds3_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds4_map" inherit_type="local" line="107" name="nf_ds4_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds4_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds5_map" inherit_type="local" line="107" name="nf_ds5_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds5_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="12" end="3283" fullname="ml_core.tests.nf_ds6_map" inherit_type="local" line="107" name="nf_ds6_Map" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/./ML_Core/ToField.ecl" start="0">
   <Signature pre="" post="" name="nf_ds6_Map">//IMPORT $.T</Signature><Type>attribute</Type>
  </Definition>
  <Definition body="2364" end="2530" exported="1" fullname="ml_core.tests.to_from" inherit_type="local" line="72" name="to_from" source="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Tests/to_from.ecl" start="2347">
   <Signature pre="" post="" name="to_from">to_from</Signature><Type>attribute</Type>
  </Definition>
 </Source>
 <Depends sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/Types.ecl" name="ML_Core.Types" target="../types.ecl.xml"/><Depends sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/FromField.ecl" name="ML_Core.FromField" target="../fromfield.ecl.xml"/><Depends sourcePath="/media/sarthak/Data/ecldoc/testing/eclbundles/ml-bundles/ML_Core/ToField.ecl" name="ML_Core.ToField" target="../tofield.ecl.xml"/></Meta>